---
title: "Berlin Airbnb Analysis"
author: "Eric Jonas, Pavlo Kravets, Simon Schäfer, Florian Tilliet"
date: "`r Sys.Date()`"
output: 
  bookdown::gitbook:
    css: "custom.css"
    code_folding: hide
bibliography: references.bib
csl: norsk-apa-manual.csl
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(scipen = 1, digits = 2)
source("code/setup.R")

full_refit = F
```

# Introduction
Airbnb is a leading online marketplace that connects homeowners with individuals seeking temporary accommodations. It operates in over 220 countries and regions, making it a global player in the hospitality industry.

Examining the factors influencing Airbnb characteristics, such as prices, is particularly interesting because these are shaped by a variety of factors like location, seasonality and local events. Understanding these influences can provide valuable insights to find the best deals for an apartment and reveal a broader impact of external factors on Airbnb accommodations. Our report will focus on [Airbnb data](https://insideairbnb.com/get-the-data/) [@corona_get_nodate] from Berlin for the years 2023 and 2024.


```{r templateFigure, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Template", fig.align='center'}

```

**TODO describe listings dataset and reviews dataset**
**TODO show in which regions are the most airbnbs**
**TODO describe (briefly!) geo datasets (crime rate, toilets, opnv, gigabit, lor, uwb)**
**TODO **

## Data Description



## Objectives

1. Number of Airbnbs by Bezirk + Overview of the Airbnb data (Florian)
2. Impact of a number of Airbnbs on price + Overview (Pavlo)
3. Influence of *Bezirk* reputation on price (Simon)
1. Impact of additional data on Airbnb price + Overview for additional data (Simon)
5. Compare price to amenities and attributes in detailed listings dataset, e.g. analyse amenities in different regions (Simon)
4. Wordcloud of names and Sentiment analysis of titles of reviews, regress to price, bezirk (Eric)

## Airbnb map

```{r airbnb-map-ggplot, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Map with ggplot", fig.align='center'}
geo_elect_units %>% 
  ggplot() + 
  geom_sf(
    mapping = aes(geometry = geometry, fill = BEZNAME)
    ) +
  geom_sf(
    data = airbnb_coordinates,
    aes(geometry = geometry),
    size = 1,
    color = "black",
    alpha = .3) +
  theme_bw() +
  theme(
    legend.position = "bottom"
  )
```

```{r airbnb-map-plotly, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Interactive map with plotly with OPNV info", fig.align='center', fig.dim = c(8, 8)}
plot_ly() %>% 
  add_sf(
    data = geo_bezirk, color = ~BEZ_NAME, 
    span = I(0.5), colors = bezirk_colors,
    hoverinfo='skip'
  ) %>% 
  add_sf(
    data = opnv_rails_no_tram_berlin,
    name = 'Rail',
    hoverinfo='skip'
    ) %>% 
  add_sf(
    data = opnv_stations_no_tram_berlin,
    name = 'Station',
    hoverinfo='skip'
  ) %>% 
  add_markers(
    data = df_airbnb,
    x = ~longitude,
    y = ~latitude,
    color = I("black"),
    text = ~str_c(price, " €"),
    hoverinfo='text',
    alpha = 0.3,
    name = 'Airbnb'
  ) %>% layout(
    legend=list(
      x=0,
      xanchor='left',
      yanchor='bottom',
      orientation='h'
    )
  )
```

# test

Schenbar nur eine plotly Karte pr Kapitel :(

```{r airbnb-map-plotly-prices, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Interactive map with plotly with OPNV info showing log prices.", fig.align='center', fig.dim = c(8, 8)}
plot_ly() %>% 
  add_sf(
    data = geo_bezirk,
    span = I(0.5),
    hoverinfo='skip'
  ) %>% 
  add_sf(
    data = opnv_rails_no_tram_berlin,
    name = 'Rail',
    hoverinfo='skip'
  ) %>% 
  add_sf(
    data = opnv_stations_no_tram_berlin,
    name = 'Station',
    hoverinfo='skip'
  ) %>% 
  add_markers(
    data = df_airbnb,
    x = ~longitude,
    y = ~latitude,
    color = ~log(price),
    text = ~str_c(price, " €"),
    hoverinfo='text',
    alpha = 0.3,
    name = 'Airbnb'
  )
```

# Regression of the influence of Bezirk reputation

```{r, include=FALSE, cache=!full_refit}
q25_mitte <- df_airbnb %>% filter(neighbourhood_group_cleansed == "Mitte") %>% 
  pull(price) %>% quantile(.25)
q75_reinickendorf <- df_airbnb %>% filter(neighbourhood_group_cleansed == "Reinickendorf") %>% 
  pull(price) %>% quantile(.75)
```

We want to estimate the influence the reputation of each *Bezirk* might have on the price for a night.^[Probably the division by *Bezirk* is too rough. A divison into *Kietz* might be more promising to find some meaningful effects.] A first comparison of the median or mean prices per *Bezirk* suggest that there might be some meaningful difference to investigate on (see Table \@ref(tab:airbnb-price-by-bezirk-table)). To stay a night in *Mitte* seems to be twice as expensive as staying in *Reinickendorf*.

```{r airbnb-price-by-bezirk-table, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, results="asis"}
cat(
  "<table>", 
  paste0("<caption>",
         "(#tab:airbnb-price-by-bezirk-table)",
         "Median and mean prices for Airbnbs per night by Bezirk as well as number of Airbnbs in each Bezirk.",
         "</caption>"),
  "</table>", 
  sep ="\n"
  )

df_airbnb %>% rename(Bezirk = neighbourhood_group_cleansed) %>% 
  group_by(Bezirk) %>% 
  summarise("mean price" = mean(price), "median price" = median(price), "#Airbnbs" = n()) %>% 
  datatable(options = list(
    info = FALSE,
    paging = FALSE,
    searching = FALSE,
    order = list(3, 'asc')
  )) %>% 
  formatCurrency(
    columns = c(2, 3),
    currency = " €",
    digits = 2,
    before = FALSE
  )
```

Figure \@ref(fig:airbnb-price-by-bezirk) shows the price for a night at Airbnbs per *Bezirk*. As was already pointed out the prices have a long tail towards higher prices. For the 25 % quantile for *Mitte* we find a value of `r q25_mitte` and for the 75 % quantile for Reinickendorf a value of `r q75_reinickendorf`. Thus for those two extreme *Bezirke* the boxes show almost no overlap. Comparing any other pair we find the boxes overlap more.

```{r airbnb-price-by-bezirk, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Showing the distribution of the price per Bezirk. Dashed line shows the 25 % quantile for Mitte and the 75 % quantile for Reinickendorf which are very close.", fig.align='center', fig.dim = c(8, 6)}
df_airbnb %>% ggplot(
  aes(
    y = neighbourhood_group_cleansed, 
    x = price, 
    fill = neighbourhood_group_cleansed)
  ) +
  geom_violin() +
  geom_boxplot(width = 0.1, fill = "white") +
  scale_fill_manual(values = bezirk_colors, name = "Bezirk") +
  ylab("Bezirk") +
  xlab("price in €") +
  theme(
    legend.position = "bottom",
    legend.title.position = "top"
  ) +
  # coord_cartesian(xlim = c(0, 250)) +
  geom_vline(xintercept = q25_mitte, lty = 2, color = "black") +
  geom_vline(xintercept = q75_reinickendorf, lty = 2, color = "black")
```

Figure \@ref(fig:airbnb-logprice-by-bezirk) shows the price for a night at Airbnbs per Bezirk on the log scale. For the remainder of this section we will use the logarithm of the Airbnb prices. Most of the price distribuitions look pretty similar. Nevertheless, we will investigate if we can find an effect on the Airbnb prices by something we model as *Bezirk* reputation.

```{r airbnb-logprice-by-bezirk, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Showing the distribution of the logarithm of the price per Bezirk. Dashed line shows the 25 % quantile for Mitte and the 75 % quantile for Reinickendorf which are very close.", fig.align='center', fig.dim = c(8, 8)}
df_airbnb %>% ggplot(
  aes(
    y = neighbourhood_group_cleansed, 
    x = log_price, 
    fill = neighbourhood_group_cleansed)
  ) +
  geom_violin() +
  geom_boxplot(width = 0.2, fill = "white") +
  scale_fill_manual(values = bezirk_colors, name = "Bezirk") +
  ylab("Bezirk") +
  xlab("log(price)") +
  theme(
    legend.position = "bottom",
    legend.title.position = "top"
  ) +
  geom_vline(xintercept = log(q25_mitte), lty = 2, color = "black") +
  geom_vline(xintercept = log(q75_reinickendorf), lty = 2, color = "black")
```

## Disclaimer

This section was written parallel to the personal revision of Bayesian regression methods. Thus one finds some discussion of DAGs and visualisation of simulated data - not only the real data from the Airbnb dataset. In the first part of the chapter one finds a step by step evolution for the first steps of the model used later with some explanations why this approach might be of value.

**tl;dr**

* This approach is valuable if one tries to estimate causal effects.
* This approach will not lead to the best predictive model.
* This approach can be used outside of a Bayesian framework as well.^[With the modern computation power at hand it is possible to follow a Bayesian path if one prefers the Bayesian probability theory premises. But one has to keep in mind that longer calculations consume more energy and thus probably contribute to higher CO<sub>2</sub> emissions.]

## Simulation of base models

```{r, include=FALSE, cache=!full_refit}
n <- 6306
mean <- log(100)
sd <- 0.5

sample_mu <- rnorm(n, mean, sd)
sample_sigma <- runif(n, 0, 1)
prior_h <- rnorm( n , sample_mu , sample_sigma )

sim_base_model <- tibble(
  sim_base_point_prior = rnorm(n, mean, sd),
  sim_base_distr_prior = prior_h,
  original = df_airbnb$log_price
)

n_bezirk <- 12
bezirke <- sample(1:12, n, replace = TRUE)
b_bezirk_reputation <- rnorm(12, 0, 0.5)
b_bezirk_reputation_distr <- rnorm(n, b_bezirk_reputation[bezirke], 0.2)
prior_bezirke = rnorm(n, sample_mu+b_bezirk_reputation_distr, sample_sigma)

sim_reputation_only_model <- tibble(
  bezirk = bezirke,
  sim_reputation = prior_bezirke,
  original = df_airbnb$log_price
)
```

Following @mcelreath_statistical_2020 book on bayesian statistics we start by specify two base models and simulate data from those to compare it with the real data. Simulating data and comparing it to real data is a good possibility to get a feeling for plausible priors [@mcelreath_statistical_2020, p. 85]. 

The most basic model possible assumes that the price just follows a given distribution (e.g. normal distribution) and that there are no influences on price. This is probably not correct. An equal approach on simulation comes from a model where we believe that the price is dependent on some variables but those variables were not measured. The corresponding DAG (directed acyclic graph) is shown in Figure \@ref(fig:dag-base-model).

```{r dag-base-model, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="DAG for most basic model", fig.align='center', fig.dim = c(4, 4)}
dag <- dagify(
  price ~ u,
  latent = "u",
  outcome = "price",
  labels = c(price = "price", u = "unobserved")
) %>% tidy_dagitty()

(ggdag_status(dag, use_labels = "label", text = FALSE) + 
  scale_fill_manual(
  labels = c("exposure", "outcome"), 
  values = c("#e41a1c", "#377eb8")
  ) +
  scale_color_manual(
  labels = c("exposure", "outcome"), 
  values = c("#e41a1c", "#377eb8")
  ) +
  theme_dag() +
  theme(
    legend.position = "bottom"
  )) %>% plot_arrows_on_top()
```

As starting values for the base model a mean price of 100 € was chosen assuming (before inspecting the real data) this might be a realistic price. This corresponds to a value of `r log(100)` on the log scale. As standard deviation \(0.5\) was chosen. The statistical model is shown in Equation \@ref(eq:base-model). 

\begin{equation} 
log(price) \sim Normal(\mu, \sigma) \\
\mu = 4.61 \\
\sigma = 0.5
(\#eq:base-model)
\end{equation} 

The statistical model formulated in Equation \@ref(eq:base-model) uses point-wise defined "priors" - and thus is not a bayesian but a frequentist model. Compare this to Equation \@ref(eq:base-model-bayesian). Here $\mu$ and $\sigma$ are distributions - not single values. The mean and standard deviation chosen in the frequentist model are both chosen in the prior for $\mu$ and $\sigma$ got a completly new distribution.

\begin{equation} 
log(price) \sim Normal(\mu, \sigma) \\
\mu \sim Normal(4.61, 0.5) \\
\sigma \sim Uniform(0, 1)
(\#eq:base-model-bayesian)
\end{equation} 

Since $\mu$ and $\sigma$ vary in the bayesian model \@ref(eq:base-model-bayesian) we find the simulated price range to be wider compared with the simulations from the frequentist model \@ref(eq:base-model). The results can be seen in Figure \@ref(fig:price-distribution-simulated). By accident the choice for the standard deviation produced a simulated distribution that is almost as wide as the real data for the baysian prior. For the frequentist prior the simulated distribution is even narrower and thus the prior standard deviation might be a little bit larger if it should be less restrictive.

```{r price-distribution-simulated, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Distribution of prices on the log scale for real data and data simulated from priors", fig.align='center'}
sim_base_model %>% 
  pivot_longer(everything()) %>% 
  mutate(
    name = factor(
      name, 
      levels = c("original", "sim_base_point_prior", "sim_base_distr_prior"), 
      labels = c("original data", "simulated data frequentist", "simulated data bayesian")
      )) %>% 
  ggplot() +
  geom_density(aes(x = value), fill = "#AACCFF") +
  facet_wrap(
    ~name, nrow = 3
    ) +
  xlab("log(price)")
```

Note, that the DAG shown in Figure \@ref(fig:dag-base-model) is corresponding to both equations. The important role of DAGs is not to define an exact statistic model but to show the beliefs about causual effects that generate the real data. It is benefitial to create a graphical represenation of the assumed casual model to select which covariables to include in the statistical model. In a DAG one can identify e.g. fork-, pipe- or collider-constallations and identify backdoor paths. Which covariable to include or exclude depends on the effect one tries to estimate (to investigate a hypothesis).

Since the goal is to estimate a possible influence of the *Bezirk* reputation it should be included in the DAG explicitly. Since there is no measurement of the *Bezirk* reputation (e.g. from a conducted survey) it is an unobserved (latent) variable. Because *Bezirk* reputation is target for our investigation we will declare it as our exposure (treatment). Moving a Airbnb from one *Bezirk* to another physically is difficult.^[Probably the *Bezirk* borders won't change in near future as well. But they do rarely.] So it might seem odd to think of *Bezirk* reputation as the treatment. But using the posterior the effect of changing the district can be calculated easily. Figure \@ref(fig:dag-reputation-only-model) shows the corresponding DAG.

```{r dag-reputation-only-model, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="DAG for most basic model", fig.align='center', fig.dim = c(6, 4)}
dag <- dagify(
  price ~ u + reputation,
  latent = c("u"),
  exposure = "reputation",
  outcome = "price",
  labels = c(price = "price", u = "unobserved", reputation = "reputation")
) %>% tidy_dagitty()

(ggdag_status(dag, use_labels = "label", text = FALSE) + 
  scale_fill_manual(
  labels = c("exposure", "outcome", "latent"), 
  values = c("#e41a1c", "#377eb8", "#4daf4a")
  ) +
  scale_color_manual(
  labels = c("exposure", "outcome", "latent"), 
  values = c("#e41a1c", "#377eb8", "#4daf4a")
  ) +
  theme_dag() +
  theme(
    legend.position = "bottom"
  )) %>% plot_arrows_on_top()
```

A corresponding statistical representation can be seen in Equation \@ref(eq:reputation-model). The simulated distribution of log prices can be seen in Figure \@ref(fig:price-distribution-simulated-reputation). The simulated distributions are spread out wider than for real data (see Figure \@ref(fig:airbnb-logprice-by-bezirk)) so that there are multiple pairs of districts where the boxes do not overlap. Thus one can assume the effect of *Bezirk* reputation be smaller than assumed in this priors.

\begin{equation} 
log(price) \sim Normal(\mu, \sigma) \\
\mu = a + Rep[i] \\
a \sim Normal(4.61, 0.5) \\
Rep[i] \sim Normal(0, 0.5) \\
\sigma \sim Uniform(0, 1)
(\#eq:reputation-model)
\end{equation} 

```{r price-distribution-simulated-reputation, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Distribution of prices on the log scale simulated from priors including reputation effect for 12 imaginary districts", fig.align='center', fig.dim = c(8, 8)}
sim_reputation_only_model %>% 
  select(-original) %>% 
  mutate(bezirk = str_c("Bezirk ", str_pad(bezirk, 2, "0", side = "left"))) %>% 
  ggplot(
    aes(
      x = sim_reputation,
      y = bezirk,
      fill = bezirk
    )) +
  geom_violin() +
  geom_boxplot(width = 0.2, fill = "white") +
  scale_fill_manual(values = bezirk_colors, name = "Bezirk") +
  ylab("Bezirk") +
  xlab("log(price)") +
  theme(
    legend.position = "bottom",
    legend.title.position = "top"
  )
```

## Dicussion of exemplary backdoor paths

A possible variable to include in the final model is the quality of residental area (*Wohnlage*) [@noauthor_wohnlagen_2024]. A high amount good *Wohnlage* in a *Bezirk* might influence its reputation. It might influence the rent or purchuse price of a flat used as Airbnb as well. So the host has to ask for higher payment per night to compensate the rent or loan installment he has to pay and maybe wants to profit by a possible good reputation of the *Bezirk* to increase his income a little more - raising the price per night once again.

In \@ref(fig:dag-reputation-model-wohnlage) one can see a model with *Wohnlage* added as a covariable. Since *Wohnlage* influences reputation as well as price there is fork pattern. *Wohnlage* is a classical confounder [@mcelreath_statistical_2020, p. 189].

```{r, include=FALSE, cache=!full_refit}
dag <- dagify(
  price ~ u + reputation + wohnlage,
  reputation ~ wohnlage,
  latent = c("u"),
  exposure = "reputation",
  outcome = "price",
  labels = c(price = "price", u = "unobserved", reputation = "reputation", wohnlage = "Wohnlage")
) %>% tidy_dagitty()
```

```{r dag-reputation-model-wohnlage, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="DAG for model with reputation and Wohnlage", fig.align='center', fig.dim = c(6, 4)}
(ggdag_status(dag, use_labels = "label", text = FALSE) + 
  scale_fill_manual(
  labels = c("exposure", "outcome", "latent"), 
  values = c("#e41a1c", "#377eb8", "#4daf4a"),
  limits = c("exposure", "outcome", "latent")
  ) +
  scale_color_manual(
  labels = c("exposure", "outcome", "latent"), 
  values = c("#e41a1c", "#377eb8", "#4daf4a"),
  limits = c("exposure", "outcome", "latent")
  ) +
  theme_dag() +
  theme(
    legend.position = "bottom"
  )) %>% plot_arrows_on_top()
```

Using a tool called dagitty [@textor_robust_2016] one can draw DAGs in the browser. Furthermore, one can get a minimal adjustment set and information on which assumptions about conditional independence would be testable if the model specified is correct. It is possible to indicate additional covariables one intends to use to check if one opens any backdoor path this way. The code for the DAG can be used to display DAGs in R as well (e.g. with the **ggdag** package). Figure \@ref(fig:dag-reputation-model-wohnlage-adjustment-set) shows that *Wohnlage* is part of the so called minimal adjustment set. Thus it has to be included to estimate (either the total or direct) causual effect.

```{r dag-reputation-model-wohnlage-adjustment-set, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="DAG for model with reputation and Wohnlage showing minimal adjustment set membership", fig.align='center', fig.dim = c(6, 4)}
(ggdag_adjustment_set(dag, use_labels = "label", text = FALSE, shadow = T) + 
  theme_dag() +
  theme(
    legend.position = "bottom"
  )) %>% plot_arrows_on_top()
```

One could also be tempted to include the results of the review sentiment analysis in the regression model. Assuming that reviews are influenced by peoples expectations and their actual experience with an Airbnb visit one can argue that is influenced by price as well as by *Bezirk* reputation. If the price is high expectations are high as well. If the reputation of the *Bezirk* is good the expectations might be high even if the price is modest. The resulting model can be seen in Figure \@ref(fig:dag-reputation-model-wohnlage-reviews).

```{r, include=FALSE, cache=!full_refit}
dag <- dagify(
  price ~ u + reputation + wohnlage,
  reputation ~ wohnlage,
  review ~ reputation + price,
  latent = c("u"),
  exposure = "reputation",
  outcome = "price",
  labels = c(price = "price", u = "unobserved", reputation = "reputation", wohnlage = "Wohnlage", review = "review")
) %>% tidy_dagitty()
```

```{r dag-reputation-model-wohnlage-reviews, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="DAG for model with reputation, Wohnlage and review", fig.align='center', fig.dim = c(6, 4)}
(ggdag_status(dag, use_labels = "label", text = FALSE) + 
  scale_fill_manual(
  labels = c("exposure", "outcome", "latent"), 
  values = c("#e41a1c", "#377eb8", "#4daf4a"),
  limits = c("exposure", "outcome", "latent")
  ) +
  scale_color_manual(
  labels = c("exposure", "outcome", "latent"), 
  values = c("#e41a1c", "#377eb8", "#4daf4a"),
  limits = c("exposure", "outcome", "latent")
  ) +
  theme_dag() +
  theme(
    legend.position = "bottom"
  )) %>% plot_arrows_on_top()
```

Once again the adjustment set only includes *Wohnlage*. Since *review* is influenced by the price and reputation it is a collider. In contrast to a fork a collider backdoor path is closed as long as the collider is not part of the model. Thus it should not be included in the model (see Figure \@ref(fig:dag-reputation-model-wohnlage-reviews-adjustment-set)).
 
```{r dag-reputation-model-wohnlage-reviews-adjustment-set, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="DAG for model with reputation, Wohnlage and review showing minimal adjustment set membership", fig.align='center', fig.dim = c(6, 4)}
(ggdag_adjustment_set(dag, use_labels = "label", text = FALSE, shadow = T) + 
  theme_dag() +
  theme(
    legend.position = "bottom"
  )) %>% plot_arrows_on_top()
```

It is important to understand that variables that are

* neither the treatment
* nor the exposure
* nor a variable marked as adjusted

are assumed to be not included in the model.

If one wants to test if an additional covariable would open backdoors one can use the `ggdag_adjust()` function. Resulting backdoor paths are displayed dashed. In Figure \@ref(fig:dag-reputation-model-wohnlage-reviews-collider) one can see that adjusting for reviews (including it in the model) opens a lot of non causal paths.^[I would recommand to use the dagitty web app instead. There the paths directly affected by the collider simply get coloured red:<br>
![dagitty collider visualization](images/dagitty_collider.png){width=50%}]

```{r dag-reputation-model-wohnlage-reviews-collider, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="DAG for model with reputation, Wohnlage and review with manual non minimal adjustment set membership showing opened backdoor paths", fig.align='center', fig.dim = c(6, 4)}
(ggdag_adjust(dag, use_labels = "label", text = FALSE, var = c("wohnlage", "review")) + 
    theme_dag() +
    theme(
      legend.position = "right"
    )) %>% plot_arrows_on_top()
```

The step by step model builing description ends at this point. In the next section the full model used for the regression analysis will be presented.

## Full model

The full model includes covariables of three types and from various sources. The covariables framed by a green rect (see Figure \@ref(fig:dag-reputation-full-model)) are features given by the Airbnb overview dataset. They yield basic information about how many people can stay there, how many rooms are there and if the Airbnb is an entire flat, a single room in a flat or a single room in a hotel.

The covariables framed by a purple rect are coming from various external data sources and were assigned to the flats by location. Most of these information is based on datasets with geographical information aggregated by *LOR* and *Urnenwahlbezirk* or calculated distances to spots of interest. We assume that distance to train stations (especially Hauptbahnhof) might influence the price but not the reputation of a district. We include distance to public toilets even though we don't assume a measurable influence on price.

Last we added more detailed information about the amenities in the Airbnbs that we extracted from the full detailed Airbnb dataset.

```{r dag-reputation-full-model, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Full DAG.", fig.align='center', fig.dim = c(8, 8)}
gg_temp <- ((ggdag_status(full_dag, use_labels = "name", text = FALSE) + 
    scale_fill_manual(
      labels = c("exposure", "outcome", "latent"), 
      values = c("#e41a1c", "#377eb8", "#4daf4a"),
      limits = c("exposure", "outcome", "latent")
    ) +
    scale_color_manual(
      labels = c("exposure", "outcome", "latent"), 
      values = c("#e41a1c", "#377eb8", "#4daf4a"),
      limits = c("exposure", "outcome", "latent")
    ) +
    theme_dag() +
    theme(
      legend.position = "bottom"
    )) %>% plot_arrows_on_top() +
  geom_rect(aes(xmin = 0, xmax = 1, ymin = 0.6, ymax = 0.875), fill = NA, color = "purple", size = 2) +
  geom_rect(aes(xmin = 0, xmax = 0.65, ymin = 0.3, ymax = 0.55), fill = NA, color = "green", size = 2) +
  geom_rect(aes(xmin = 0.68, xmax = 1, ymin = 0.3, ymax = 0.575), fill = NA, color = "orange", size = 2)
  ) %>% layer_on_bottom(5) %>% layer_on_bottom(6) %>% layer_on_bottom(7)
plot(gg_temp)
```

It seems plausible that crime rates influence the reputation of an district. And there are theories predicting higher crime rated for regions with lower living standards. Thus we get a new backdoor path there - but it is already closed when the model is adjusted for *Wohnlage* (see Figure \@ref(fig:dag-reputation-full-model-minimal-adjustment-set)). Crime rate is not included in the final models because it possibly explaines variance of *Bezirk* reputation and thus lower the covariance to price (precision parasite effect) as well as amplicate the bias of unobserved confounds between exposure and target.^[Closing all backdoor paths is not the only criteria to choose covariables on. There are other effects to consider.]

```{r dag-reputation-full-model-minimal-adjustment-set, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Full DAG with minimal adjustment set. Only Wohnlage is nedded to close backdoor paths.", fig.align='center', fig.dim = c(8, 8)}
(ggdag_adjustment_set(full_dag, use_labels = "name", text = FALSE, shadow = T) + 
  theme_dag() +
  theme(
    legend.position = "bottom"
  )) %>% plot_arrows_on_top() 
```

Indicating that all variables but reviews should be included in the model shows no non-closed backdoor paths (see Figure \@ref(fig:dag-reputation-full-model-adjustment-set)). Thus the model might yield an unconfounded estimator for the effect of the *Bezirk* reputation. The reason to include other covariables than those from the minimal adjustment set is that we hope to reduce the variance in the Airbnb price by reducing the amount of unobserved sources of variance. Hopefully this leads to narrower posterior predictions to identify a possible causual effect of the *Bezirk* reutation.

```{r dag-reputation-full-model-adjustment-set, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Full DAG with all covariables included in the model marked as adjusted. No new backdoor paths opened.", fig.align='center', fig.dim = c(8, 8)}
(ggdag_adjustment_set(full_dag_adjusted, use_labels = "name", text = FALSE, shadow = T) +
  theme_dag() +
  theme(
    legend.position = "bottom",
    strip.background = element_blank(),
    strip.text.x = element_blank()
  )) %>% plot_arrows_on_top()
```

## Regression

```{r, include=FALSE, cache=!full_refit}
# base model
base_model_post <- readRDS("saved_objects/base_model_post.rds")
base_model_student_post <- readRDS("saved_objects/base_model_student_post.rds")

max_pred_base <- base_model_post %>% 
  mutate(price = exp(rnorm(1000, mu, sigma))) %>% pull(price) %>% max()
max_pred_base_student <- base_model_student_post %>% 
  mutate(price = exp(rstudent(1000, 2, mu, sigma))) %>% pull(price) %>% max()
sigma_base_model <- mean(base_model_post$sigma)
sigma_base_model_student <- mean(base_model_student_post$sigma)

# minimal adjustement set
base_model_reputation_wohnlage_post <- readRDS("saved_objects/base_model_reputation_wohnlage_post.rds")
base_model_reputation_wohnlage_student_post <- readRDS("saved_objects/base_model_reputation_wohnlage_student_post.rds")

# full model
full_model_post <- readRDS("saved_objects/full_model_post.rds")
full_model_verbose_post <- readRDS("saved_objects/full_model_verbose_post.rds")
```

### Baseline models

We will begin with the presentation of the most basic models and demonstrate some common visualizations for Bayesian regression reports. Precisely, we will...

* distinguish between parameter estimates and posterior predictions.
* distinguish between parameter estimations and predicted effect (by contrating predictions).
* show the influence of robust regression assuming student distributed prices instead of normal distributed ones (not bound to Bayesian methods).

In Figure \@ref(fig:base-model-4x4) one can see the difference between the parameter estimation (distribution) of the mean price (left) and the posterior predictions for the distribution of Airbnb prices (right) for the model represented by Figure \@ref(fig:dag-base-model). It is clear that the distribution of the prices is much wider than the estimated distribution of the mean value since one has to exponentiate the result of the random sampling around the mean.

Comparing the results from the model with $Normal(\mu, \sigma)$ distributed prices (top) with the results from the model that assumed $Student(2, \mu, \sigma)$ distributed prices (bottom) we find lower mean price for the student model. For the price distributions we find more Airbnb prices in the range (200 €, 400 €) for the normal model. In contrast we find thicker tails for the student model so more predictions about Airbnb prices higher than 400 €. The mean $\sigma$ value for the normal model is `r sigma_base_model` and for the student model `r sigma_base_model_student`. The maximum price for an Airbnb is `r max_pred_base` € and respective `r format(max_pred_base_student, scientific=FALSE, big.mark="_")` €. For the studnet distribution we find more Airbnb prices predicted to be  around 0 €.

```{r base-model-4x4, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Comparing parameter estimations and posterior predictions (left vs right) and assumed normal and student distributed prices (top vs bottom). The x-axis is clipped at 800 €.", fig.align='center', fig.dim = c(8, 8)}
g_param_norm <- base_model_post %>% 
  mutate(price = exp(mu)) %>% 
  ggplot(aes(x = price)) +
  stat_halfeye(.width = c(.90, .5)) +
  labs(x=NULL, y=NULL) +
  coord_cartesian(xlim = c(100, 108))

g_pred_norm <- base_model_post %>% 
  mutate(price = exp(rnorm(1000, mu, sigma))) %>% 
  ggplot(aes(x = price)) +
  stat_halfeye(.width = c(.90, .5)) +
  labs(x=NULL, y=NULL) +
  xlim(0, 800)

g_param_student <- base_model_student_post %>% 
  mutate(price = exp(mu)) %>% 
  ggplot(aes(x = price)) +
  stat_halfeye(.width = c(.90, .5)) +
  labs(x=NULL, y=NULL) +
  coord_cartesian(xlim = c(100, 108))

g_pred_student <- base_model_student_post %>%
  rowwise() %>% mutate(price = exp(rstudent(1, 2, mu, sigma))) %>% 
  ggplot(aes(x = price)) +
  stat_halfeye(.width = c(.90, .5)) +
  labs(x=NULL, y=NULL) +
  xlim(0, 800)

p <- list(g_param_norm, g_pred_norm, g_param_student, g_pred_student)

yleft = gridtext::richtext_grob("density", rot=90)
bottom = gridtext::richtext_grob(
  text = 'price in €'
)

gridExtra::grid.arrange(
  grobs = p, 
  nrow = 2, 
  left = yleft, bottom = bottom
)
```

In Figure \@ref(fig:base-model-rep-wol-parameter) on can compare the parameter estimation for a normal and a student distributed model once more. The DAG corresponding to the model these results are based on is shown in Figure \@ref(fig:dag-reputation-model-wohnlage). The means are estimated for each *Bezirk* and according to each value of *Wohnlage*. We can see that the means for highest value of *Wohnlage* are seperated from those of the lower two values. For the latter there is substantial overlap of the distributions. The separation seems a little bit better for the student model. It is also clear that some parameter distributions show no overlap comparing the same *Wohnlage* among districts.

```{r base-model-rep-wol-parameter, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Comparing parameter estimations for assumed normal and student distributed prices (top vs bottom).", fig.align='center', fig.dim = c(8, 8)}
g_param_norm <- base_model_reputation_wohnlage_post %>% 
  pivot_wider(names_from = "wohnlage", values_from = "delta", names_prefix = "wol_") %>% 
  mutate(
    price_wol_1 = exp(reputation+bE*(wol_1)),
    price_wol_2 = exp(reputation+bE*(wol_1+wol_2)),
    price_wol_3 = exp(reputation+bE*(wol_1+wol_2+wol_3))
    ) %>% pivot_longer(cols = starts_with("price_"), values_to = "price", names_prefix = "price_wol_", names_to = "wohnlage") %>% 
  mutate(bezirk = bezirk_levels[bezirk]) %>% 
  ggplot(aes(x = price, y = bezirk, fill = wohnlage)) +
  stat_slab(.width = c(.90, .5), alpha = .5) +
  labs(x=NULL, y=NULL)

g_param_student <- base_model_reputation_wohnlage_student_post %>% 
  pivot_wider(names_from = "wohnlage", values_from = "delta", names_prefix = "wol_") %>% 
  mutate(
    price_wol_1 = exp(reputation+bE*(wol_1)),
    price_wol_2 = exp(reputation+bE*(wol_1+wol_2)),
    price_wol_3 = exp(reputation+bE*(wol_1+wol_2+wol_3))
  ) %>% pivot_longer(cols = starts_with("price_"), values_to = "price", names_prefix = "price_wol_", names_to = "wohnlage") %>% 
  mutate(bezirk = bezirk_levels[bezirk]) %>% 
  ggplot(aes(x = price, y = bezirk, fill = wohnlage)) +
  stat_slab(.width = c(.90, .5), alpha = .5) +
  labs(x=NULL, y=NULL)

ggpubr::ggarrange(
  plotlist = list(g_param_norm, g_param_student), 
  nrow = 2,
  common.legend = TRUE, legend = "bottom"
)
```

To get an estimation of the causual effect of the *Bezirks* reputation it is necessary to inspect contrast plots (see Figure \@ref(fig:base-model-rep-wol-parameter-contrasts)). To limit the amount of comparisons the districts *Mitte* (high prices), *Neukölln* and *Tempelhof-Schöneberg* (medium prices) as well as *Reinickendorf* (low prices) have been selected. It can be seen that the mean price (aggregated over all *Wohnlagen*^[To be correct one would have to select prices according to the distribution of the *Wohnlage* values per district. It was assumed that they all make up one third in each distric to simplify the analysis.]) differ by more than 10 € for all comparisons but for the apir *Neukölln* and *Tempelhof*. One could conclude that teleporting an Airbnb from *Reinickendorf* to *Mitte* allows for a price increase of around 50 €.

```{r base-model-rep-wol-parameter-contrasts, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Bla.", fig.align='center', fig.dim = c(8, 6)}
bdat <- base_model_reputation_wohnlage_post %>% 
  pivot_wider(names_from = "wohnlage", values_from = "delta", names_prefix = "wol_") %>% 
  mutate(
    price_wol_1 = exp(reputation+bE*(wol_1)),
    price_wol_2 = exp(reputation+bE*(wol_1+wol_2)),
    price_wol_3 = exp(reputation+bE*(wol_1+wol_2+wol_3))
  ) %>% pivot_longer(cols = starts_with("price_"), values_to = "price", names_prefix = "price_wol_", names_to = "wohnlage") %>% 
  mutate(bezirk = bezirk_levels[bezirk]) %>% 
  filter(bezirk %in% c("Mitte", "Tempelhof-Schöneberg", "Neukölln", "Reinickendorf")) %>% 
  select(bezirk, price, wohnlage, .draw, .chain, .iteration) %>% 
  pivot_wider(names_from = bezirk, values_from = price, names_prefix = "price_")
  
adat <- bdat %>% 
  select(starts_with("price_"))

# Get column names
nm1 <- outer(colnames(adat), colnames(adat), paste, sep="_-_")

# Indices for lower triangular elements (excluding diagonal)
indx1 <- which(lower.tri(nm1, diag=TRUE))

# Calculate pairwise differences
res <- outer(1:ncol(adat), 1:ncol(adat), function(x, y) adat[, x] - adat[, y])

# Set column names for the resulting dataframe
colnames(res) <- nm1
res1 <- res[-indx1]

area <- 10
res1 %>% bind_cols(
  bdat %>% select(-starts_with("price_")) # %>% rename(wohnlage = name)
) %>% 
  pivot_longer(starts_with("price_"), values_to = "price_diff") %>% 
  mutate(
    name = str_replace(name, "_-_", " - ") %>% str_remove_all("price_")
  ) %>% 
  ggplot(aes(x = price_diff, y = name, fill = stat(abs(x) > area))) +
  stat_halfeye() +
  geom_vline(xintercept = c(-area, area), linetype = "dashed") +
  scale_fill_manual(values = c("gray80", "skyblue")) +
  labs(x="difference of mean price in €", y=NULL) +
  theme(
    legend.position = "bottom"
  )
```

Next we will inspect how this difference in mean price is related to the prediction of the Airbnb price distribution (see Figure \@ref(fig:base-model-rep-wol-predictions)). Here the price distributions for the normal and student model look pretty similar. The thicker tails for the student model are barely visible. But the maximum predicted price is (again) much to high and there are many predictions around 0 €. Thus we won't use the student modeling approach for the full model later.

The price distributions for all values of *Wohnlage* almost totally overlap even though the parameter estimations for their means were good distinguishable. Beside from the distributions for *Reinickendorf* and *Marzahn-Hellersdorf* (which are a little bit more left skewed) they all look pretty similar as well in this plot.

```{r base-model-rep-wol-predictions, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Comparing posterior predictions for assumed normal and student distributed prices (top vs bottom). The x-axis is clipped by 500 €.", fig.align='center', fig.dim = c(8, 8)}
g_pred_norm <- base_model_reputation_wohnlage_post %>% 
  pivot_wider(names_from = "wohnlage", values_from = "delta", names_prefix = "wol_") %>% 
  rowwise() %>% 
  mutate(
    price_wol_1 = exp(rnorm(1, reputation+bE*(wol_1), sigma)),
    price_wol_2 = exp(rnorm(1, reputation+bE*(wol_1+wol_2), sigma)),
    price_wol_3 = exp(rnorm(1, reputation+bE*(wol_1+wol_2+wol_3), sigma))
  ) %>% pivot_longer(cols = starts_with("price_"), values_to = "price", names_prefix = "price_wol_", names_to = "wohnlage") %>% 
  mutate(bezirk = bezirk_levels[bezirk]) %>% 
  ggplot(aes(x = price, y = bezirk, fill = wohnlage)) +
  stat_slab(.width = c(.90, .5), alpha = .5) +
  labs(x=NULL, y=NULL) +
  xlim(0, 500)

g_pred_student <- base_model_reputation_wohnlage_student_post %>%
  pivot_wider(names_from = "wohnlage", values_from = "delta", names_prefix = "wol_") %>% 
  rowwise() %>% 
  mutate(
    price_wol_1 = exp(rstudent(1, 2, reputation+bE*(wol_1), sigma)),
    price_wol_2 = exp(rstudent(1, 2, reputation+bE*(wol_1+wol_2), sigma)),
    price_wol_3 = exp(rstudent(1, 2, reputation+bE*(wol_1+wol_2+wol_3), sigma))
  ) %>% pivot_longer(cols = starts_with("price_"), values_to = "price", names_prefix = "price_wol_", names_to = "wohnlage") %>% 
  mutate(bezirk = bezirk_levels[bezirk]) %>% 
  ggplot(aes(x = price, y = bezirk, fill = wohnlage)) +
  stat_slab(.width = c(.90, .5), alpha = .5) +
  labs(x=NULL, y=NULL) +
  xlim(0, 500)

ggpubr::ggarrange(
  plotlist = list(g_pred_norm, g_pred_student), 
  nrow = 2,
  common.legend = TRUE, legend = "bottom"
)
```

To investigate the difference of the predicted price distributions we once again create a contrast plot (see Figure \@ref(fig:base-model-rep-wol-predictions-contrasts)). One can see that the distributions of price differences have an considerable amount of mass on both sides of zero. Nevertheless, the probability to get a lower price for an Airbnb in *Reinickendorf* than in *Mitte* is predicted as 75.6 %. The probability to safe more than 10 €per night is still 70.4 %. Even though it was hard to see any difference without the contrast plot and with zero near to the peak of probability distributions we find results that are meaningful for in reality.

```{r base-model-rep-wol-predictions-contrasts, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Contrast plot of price difference among four districts. Positive values: one safes money if one books an Airbnb in the *Bezirk* named right of the minus sign.", fig.align='center', fig.dim = c(8, 6)}
bdat <- base_model_reputation_wohnlage_post %>% 
  pivot_wider(names_from = "wohnlage", values_from = "delta", names_prefix = "wol_") %>%
  rowwise() %>% 
  mutate(
    price_wol_1 = exp(rnorm(1, reputation+bE*(wol_1), sigma)),
    price_wol_2 = exp(rnorm(1, reputation+bE*(wol_1+wol_2), sigma)),
    price_wol_3 = exp(rnorm(1, reputation+bE*(wol_1+wol_2+wol_3), sigma))
  ) %>% pivot_longer(cols = starts_with("price_"), values_to = "price", names_prefix = "price_wol_", names_to = "wohnlage") %>% 
  mutate(bezirk = bezirk_levels[bezirk]) %>% 
  filter(bezirk %in% c("Mitte", "Tempelhof-Schöneberg", "Neukölln", "Reinickendorf")) %>% 
  select(bezirk, price, wohnlage, .draw, .chain, .iteration) %>% 
  pivot_wider(names_from = bezirk, values_from = price, names_prefix = "price_")

adat <- bdat %>% 
  select(starts_with("price_"))

# Get column names
nm1 <- outer(colnames(adat), colnames(adat), paste, sep="_-_")

# Indices for lower triangular elements (excluding diagonal)
indx1 <- which(lower.tri(nm1, diag=TRUE))

# Calculate pairwise differences
res <- outer(1:ncol(adat), 1:ncol(adat), function(x, y) adat[, x] - adat[, y])

# Set column names for the resulting dataframe
colnames(res) <- nm1
res1 <- res[-indx1]

df_temp <- res1 %>% bind_cols(
  bdat %>% select(-starts_with("price_")) # %>% rename(wohnlage = name)
) %>% 
  pivot_longer(starts_with("price_"), values_to = "price_diff") %>% 
  mutate(
    name = str_replace(name, "_-_", " - ") %>% str_remove_all("price_")
  )

df_temp %>% left_join(
  df_temp %>% group_by(name) %>% summarise(p_safe = round(100*mean(price_diff > 0),1)) %>% 
    mutate(p_safe = str_c(p_safe, " %"))
) %>% 
  ggplot(aes(x = price_diff, y = name, fill = stat(x > 0))) +
  stat_halfeye() +
  geom_vline(xintercept = 0, linetype = "dashed") +
  scale_fill_manual(values = c("gray80", "skyblue")) +
  labs(x="difference of predicted price in €", y=NULL) +
  geom_text(aes(x = 80, y = as.integer(as.factor(name))+0.15, label = p_safe)) +
  coord_cartesian(xlim = c(-350, 350)) +
  theme(
    legend.position = "bottom"
  )

p_safe_10 <- (df_temp %>% group_by(name) %>% summarise(p_safe_10 = round(100*mean(price_diff > 10), 2)))[[2,2]]
```

To conclude this section we want to state:

* There is important difference between parameter distributions and distributions of predictions. The prediction distributions are wider. This is not bad but honest. Do not report the parameter distributions only. Uncertainty is nothing to one has to hide but important to make theougtful decisions.
* The causual effect has to be insprected via contrats not by overlaying distributions. Most of the time low values in one distribution correspond to low values in the other one so the difference is consistent.
* Even though the student distribution should yield models that are more robust to outliers they also generate outliers as predictions. It is nothiung you can get your distributions narrower with.^[I was tempted to use a normal distribution for prediction with the $\sigma$ from the student analysis because than the distributions are narrower. It looks like the model is more certain. But to my current understanding this might be cheating towards nicer results.]

### Full model

The full models DAG was already presented in Figure \@ref(fig:dag-reputation-full-model). For the full model all additional covariables were either included as numeric predictors and scaled before or treated as binomial. The only covariable modeled as ordered predictor is *Wohnlage*. Treating covariables like number of rooms was simpler. In a real analysis one might take the time to e.g. model number of bathrooms as ordered instead of numeric predictor because it makes more difference if there are zero or one bathrooms compared to two or three. And it makes no sense to predict negative room numbers or fractions on a finer grain than a half.

The estimations and predictions in the next figures are based on the average values for numeric predictors (e.g. an average number of beds for an average number of accommodates) for Airbnbs with minimal amenities. This means no WiFi, TV or sauna and no kitchen at all. The next section will discuss if the parameter estimations from our model can be interpreted as causal effects and thus contrast plots for these covariables might be of interest as well.

In Figure \@ref(fig:full-model-parameter) once again one can see the parameter estimations for Airbnbs in different districts grouped by *Wohnlage* and this time grouped by property type as well. Again, the estimation for a *Wohnlage* value of tree is seperated from the other two levels. But the parameter distributions seem to be seperable especially by the type of property. A shared room is less expansive. A hotel room is most expensive. This is probably the criteria that made Airbnb big in the first place. One can get a whole flat for less than a single hotel room. One can see that the estimation for hotel rooms are pretty wide. This reflects the uncertainty related to the low number of data points for hotel rooms in the Airbnb dataset.

```{r full-model-parameter, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Comparing parameter estimations for mean Airbnb prices by *Bezirk* grouped by property type and *Wohnlage*.", fig.align='center', fig.dim = c(8, 8)}
full_model_post %>%
  pivot_wider(names_from = "wohnlage", values_from = "delta", names_prefix = "wol_") %>% 
  mutate(
    price_wol_1 = exp(reputation+bE*(wol_1)+bPT),
    price_wol_2 = exp(reputation+bE*(wol_1+wol_2)+bPT),
    price_wol_3 = exp(reputation+bE*(wol_1+wol_2+wol_3)+bPT)
  ) %>% pivot_longer(cols = starts_with("price_"), values_to = "price", names_prefix = "price_wol_", names_to = "wohnlage") %>% 
  mutate(bezirk = bezirk_levels[bezirk], property_type = property_type_levels[property_type]) %>% 
  ggplot(aes(x = price, y = bezirk, fill = wohnlage, color = property_type)) +
  stat_slab(.width = c(.90, .5), alpha = .5) +
  labs(x=NULL, y=NULL) +
  theme(
    legend.position = "bottom"
  )
```

Since even the price distributions for mean prices spread out above 200 € it gets pretty hard to get any idea about differences caused by *Bezirk* reputation. In Figure \@ref(fig:full-model-parameter-contrasts) we find the contrasts aggregated over all levels of *Wohnlage* and property types. In this case none of the comparisons of the estimated mean prices is free of overlap. Interestingly it seems like *Neukölln* is now more similar to *Mitte* than to *Tempelhof-Schöneberg*. In fact *Neukölln* seems to be even more expensive than *Mitte*. A possible explanantion for this could be the amenities. If the Airbnbs in *Mitte* have better amenities than in *Neuköln* this can explain the higher prices found at the first inspection of the data.

```{r full-model-parameter-contrasts, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Bla.", fig.align='center', fig.dim = c(8, 6)}
bdat <- full_model_post %>% 
  pivot_wider(names_from = "wohnlage", values_from = "delta", names_prefix = "wol_") %>% 
  mutate(
    price_wol_1 = exp(reputation+bE*(wol_1)+bPT),
    price_wol_2 = exp(reputation+bE*(wol_1+wol_2)+bPT),
    price_wol_3 = exp(reputation+bE*(wol_1+wol_2+wol_3)+bPT)
  ) %>% pivot_longer(cols = starts_with("price_"), values_to = "price", names_prefix = "price_wol_", names_to = "wohnlage") %>% 
  mutate(bezirk = bezirk_levels[bezirk], property_type = property_type_levels[property_type]) %>% 
  filter(bezirk %in% c("Mitte", "Tempelhof-Schöneberg", "Neukölln", "Reinickendorf")) %>% 
  select(bezirk, price, wohnlage, .draw, .chain, .iteration, property_type) %>% 
  pivot_wider(names_from = bezirk, values_from = price, names_prefix = "price_")

adat <- bdat %>% ungroup() %>% 
  select(starts_with("price_"))

# Get column names
nm1 <- outer(colnames(adat), colnames(adat), paste, sep="_-_")

# Indices for lower triangular elements (excluding diagonal)
indx1 <- which(lower.tri(nm1, diag=TRUE))

# Calculate pairwise differences
res <- outer(1:ncol(adat), 1:ncol(adat), function(x, y) adat[, x] - adat[, y])

# Set column names for the resulting dataframe
colnames(res) <- nm1
res1 <- res[-indx1]

area <- 10
res1 %>% bind_cols(
  bdat %>% select(-starts_with("price_")) # %>% rename(wohnlage = name)
) %>% 
  pivot_longer(starts_with("price_"), values_to = "price_diff") %>% 
  mutate(
    name = str_replace(name, "_-_", " - ") %>% str_remove_all("price_")
  ) %>% 
  ggplot(aes(x = price_diff, y = name, fill = stat(abs(x) > area))) +
  stat_halfeye() +
  geom_vline(xintercept = c(-area, area), linetype = "dashed") +
  scale_fill_manual(values = c("gray80", "skyblue")) +
  labs(x="difference of mean price in €", y=NULL) +
  theme(
    legend.position = "bottom"
  )
```

In Figure \@ref(fig:full-model-parameter-roomtype-contrasts) the mean price diistributions are inspected seperated by property type. One can see that the clear distinction in mean price is found for entire homes/apartments, as well as for private and hotel rooms. In contrats the difference for a shared romm is much smaller among the districts.

```{r full-model-parameter-roomtype-contrasts, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Bla.", fig.align='center', fig.dim = c(8, 8)}
area <- 10
res1 %>% bind_cols(
  bdat %>% select(-starts_with("price_")) # %>% rename(wohnlage = name)
) %>% 
  pivot_longer(starts_with("price_"), values_to = "price_diff") %>% 
  mutate(
    name = str_replace(name, "_-_", " - ") %>% str_remove_all("price_")
  ) %>% 
  ggplot(aes(x = price_diff, y = name, fill = stat(abs(x) > area))) +
  stat_halfeye() +
  geom_vline(xintercept = c(-area, area), linetype = "dashed") +
  scale_fill_manual(values = c("gray80", "skyblue")) +
  labs(x="difference of mean price in €", y=NULL) +
  facet_wrap(~property_type) +
  theme(
    legend.position = "bottom"
  )
```

Finally we will show the results for the posterior predictions for the actual Airbnb prices. From Figure \@ref(fig:full-model-pred) one can see that there is substantial overlap among all distributions as already found before. Nevertheless, one can distinguish the order of prices that might be related to property type.

```{r full-model-pred, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Comparing posterior predictions for Airbnb prices by *Bezirk* grouped by property type and *Wohnlage*.", fig.align='center', fig.dim = c(8, 8)}
full_model_post %>%
  pivot_wider(names_from = "wohnlage", values_from = "delta", names_prefix = "wol_") %>% 
  rowwise() %>% 
  mutate(
    price_wol_1 = exp(rnorm(1, reputation+bE*(wol_1)+bPT, sigma)),
    price_wol_2 = exp(rnorm(1, reputation+bE*(wol_1+wol_2)+bPT, sigma)),
    price_wol_3 = exp(rnorm(1, reputation+bE*(wol_1+wol_2+wol_3)+bPT, sigma))
  ) %>% pivot_longer(cols = starts_with("price_"), values_to = "price", names_prefix = "price_wol_", names_to = "wohnlage") %>% 
  mutate(bezirk = bezirk_levels[bezirk], property_type = property_type_levels[property_type]) %>% 
  ggplot(aes(x = price, y = bezirk, fill = wohnlage, color = property_type)) +
  stat_slab(.width = c(.90, .5), alpha = .5) +
  labs(x=NULL, y=NULL) +
  coord_cartesian(xlim = c(0, 500)) +
  theme(
    legend.position = "bottom"
  )
```

From the contrasts plot aggregated over *Wohnlage* and property type (see Figure \@ref(fig:full-model-pred-contrasts)) one can see that the probability to find a cheaper Airbnb (with equal amenities and size) decreaded from 73 % to 65 % for the pair *Mitte*-*Reinickendorf* but increased slightly from 66 % to 67 % for the pair *Neukölln*-*Reinickendorf*. In general the probability to find a difference came closer to 50 %. Thus the causual effect of *Bezirk* reputation seems to be smaller than estimated with the model only accounting for the minimal adjustment set. This seems plausible since we possibly compared luxurious Airbnb against more simple ones before. Now the model can account for these sources of variance in the target variable.

```{r full-model-pred-contrasts, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Bla.", fig.align='center', fig.dim = c(8, 6)}
bdat <- full_model_post %>% 
  pivot_wider(names_from = "wohnlage", values_from = "delta", names_prefix = "wol_") %>% 
  rowwise() %>% 
  mutate(
    price_wol_1 = exp(rnorm(1, reputation+bE*(wol_1)+bPT, sigma)),
    price_wol_2 = exp(rnorm(1, reputation+bE*(wol_1+wol_2)+bPT, sigma)),
    price_wol_3 = exp(rnorm(1, reputation+bE*(wol_1+wol_2+wol_3)+bPT, sigma))
  ) %>% pivot_longer(cols = starts_with("price_"), values_to = "price", names_prefix = "price_wol_", names_to = "wohnlage") %>% 
  mutate(bezirk = bezirk_levels[bezirk], property_type = property_type_levels[property_type]) %>% 
  filter(bezirk %in% c("Mitte", "Tempelhof-Schöneberg", "Neukölln", "Reinickendorf")) %>% 
  select(bezirk, price, wohnlage, .draw, .chain, .iteration, property_type) %>% 
  pivot_wider(names_from = bezirk, values_from = price, names_prefix = "price_")

adat <- bdat %>% ungroup() %>% 
  select(starts_with("price_"))

# Get column names
nm1 <- outer(colnames(adat), colnames(adat), paste, sep="_-_")

# Indices for lower triangular elements (excluding diagonal)
indx1 <- which(lower.tri(nm1, diag=TRUE))

# Calculate pairwise differences
res <- outer(1:ncol(adat), 1:ncol(adat), function(x, y) adat[, x] - adat[, y])

# Set column names for the resulting dataframe
colnames(res) <- nm1
res1 <- res[-indx1]

df_temp <- res1 %>% bind_cols(
  bdat %>% select(-starts_with("price_")) # %>% rename(wohnlage = name)
) %>% 
  pivot_longer(starts_with("price_"), values_to = "price_diff") %>% 
  mutate(
    name = str_replace(name, "_-_", " - ") %>% str_remove_all("price_")
  )

df_temp %>% left_join(
  df_temp %>% group_by(name) %>% summarise(p_safe = round(100*mean(price_diff > 0),1)) %>% 
    mutate(p_safe = str_c(p_safe, " %"))
) %>% 
  ggplot(aes(x = price_diff, y = name, fill = stat(x > 0))) +
  stat_halfeye() +
  geom_vline(xintercept = 0, linetype = "dashed") +
  scale_fill_manual(values = c("gray80", "skyblue")) +
  labs(x="difference of predicted price in €", y=NULL) +
  geom_text(aes(x = 80, y = as.integer(as.factor(name))+0.15, label = p_safe)) +
  coord_cartesian(xlim = c(-250, 250)) +
  theme(
    legend.position = "bottom"
  )

p_safe_10 <- (df_temp %>% group_by(name, property_type) %>% summarise(p_safe_10 = round(100*mean(price_diff > 10), 2)))[[2,2]]
```

Inspecting the posterior predictions separated by property type (see Figure \@ref(fig:full-model-pred-roomtype-contrasts)) does not show new interesting patterns. This was different when the mean price distributions were inspected.

```{r full-model-pred-roomtype-contrasts, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Bla.", fig.align='center', fig.dim = c(8, 8)}
df_temp %>% left_join(
  df_temp %>% group_by(name, property_type) %>% summarise(p_safe = round(100*mean(price_diff > 0),1)) %>% 
    mutate(p_safe = str_c(p_safe, " %"))
) %>% 
  ggplot(aes(x = price_diff, y = name, fill = stat(x > 0))) +
  stat_halfeye() +
  geom_vline(xintercept = 0, linetype = "dashed") +
  scale_fill_manual(values = c("gray80", "skyblue")) +
  labs(x="difference of predicted price in €", y=NULL) +
  geom_text(aes(x = 150, y = as.integer(as.factor(name))+0.35, label = p_safe)) +
  coord_cartesian(xlim = c(-250, 250))+
  facet_wrap(~property_type) +
  theme(
    legend.position = "bottom"
  )
```

### Alternative interpretations

From the visualizations above the question might arise if the full model also yields estimation of the causal effects of other covariables. This question can not be answered without inspecting the corresponding DAG (see Figure \@ref(fig:dag-reputation-full-model)).

For all covariables that show only an arrow that is entering the target variable the parameter estimations of the full model can be interpreted as the total and direct causal effect. This is true for all amenities that are not related to having a kitchen, e.g. TV and board games as well as sauna or piano. This is also true for:

* number of traffic accidents
* distance to next public toilet
* distance to Hauptbahnhof (even though there is an entering arrow from distance to next train station)
* number of bathrooms
* property type

For *Wohnlage* the estimated parameter only can be interpreted as the direct effect but not as the total casual effect. Same holds for:

* number of accommodates
* number of bedrooms
* kitchen
* amenities linked to kitchen
* WiFi
* gigabit supply
* distance to next train stations

The mean of the parameter estimation as well as indicators of their distribution width can be found in \@ref(tab:full-model-parameter-summary). This table also indicates if the parameter can be interpreted as total and direct causal effect or only as direct causal effect. The table is linked with Figure \@ref(fig:full-model-parameter-contrasts-interactive) and Figure \@ref(fig:full-model-pred-contrasts-interactive) which show the contrast plots for the selected covariable. Figure \@ref(fig:full-model-parameter-contrasts-interactive) shows the effect on the mean price while Figure \@ref(fig:full-model-pred-contrasts-interactive) shows the effect for the predicted actual prices.^[It might be necassary to zoom a little bit out to see all three depending on the size and resolution of the screen. Since the interactive plotly apps produce a lot of data that has to be stored and loaded in the HTML document the densities are generated by 20 data points per parameter only. The percentages are computed on all data points and thus more precise.]

The model is often pretty sure that the mean price for an Airbnb with a selected amenity (or with an increased value by one standard deviation for a numeric predictor) is higher (or lower). Nevertheless, the model is much less certein that prices actually found in reality will be higher (or lower) for most Airbnbs. E.g. the model is 100 % certain that an Airbnb with balcony is in general (mean) more expensive than one without. But it predicts only a 55 % probability that for a given pair of Airbnbs the one with a a balcony is more expensive than one without. For an Airbnb where a number of accommodates is one standard deviation higher than for the population mean the model is 100 % certain that the mean price is higher. For an actual pair it predicts 64 % probability that the Airbnb with space for more accommodates ist more expensive.

```{r prepare-interactive-data, include=FALSE, cache=FALSE}
full_model_verbose_post_summary <- readRDS("saved_objects/full_model_verbose_post_summary.rds") %>% 
  select(-rhat, -ess_bulk) %>% 
  filter(!str_starts(parameter, "delta")) %>% 
  filter(!str_starts(parameter, "reputation")) %>% 
  filter(!str_starts(parameter, "bPropType")) %>% 
  filter(parameter != "sigma") %>% 
  mutate("total effect" = parameter %in% direct_effect_only)

full_model_verbose_post_long <- full_model_verbose_post %>% 
  pivot_wider(names_from = "wohnlage", values_from = "delta", names_prefix = "wol_") %>% 
  mutate(
    log_price_wol_1 = reputation+bE*(wol_1)+bPropType,
    log_price_wol_2 = reputation+bE*(wol_1+wol_2)+bPropType,
    log_price_wol_3 = reputation+bE*(wol_1+wol_2+wol_3)+bPropType
  ) %>% pivot_longer(cols = starts_with("log_price_"), values_to = "log_price", names_prefix = "log_price_wol_", names_to = "wohnlage") %>% 
  mutate(bezirk = bezirk_levels[bezirk], property_type = property_type_levels[property_type]) %>% 
  pivot_longer(full_model_verbose_post_summary$parameter) %>% 
  mutate(price_diff = exp(log_price+value)-exp(log_price)) %>%
  group_by(name) %>% 
  mutate(perc = str_c(round(100*mean(price_diff>0), 2), " %")) %>% 
  sample_n(20) %>% 
  ungroup() %>% 
  select(name, price_diff, perc)

full_model_verbose_post_long_pred <- full_model_verbose_post %>% 
  pivot_wider(names_from = "wohnlage", values_from = "delta", names_prefix = "wol_") %>% 
  mutate(
    log_price_wol_1 = reputation+bE*(wol_1)+bPropType,
    log_price_wol_2 = reputation+bE*(wol_1+wol_2)+bPropType,
    log_price_wol_3 = reputation+bE*(wol_1+wol_2+wol_3)+bPropType
  ) %>% pivot_longer(cols = starts_with("log_price_"), values_to = "log_price", names_prefix = "log_price_wol_", names_to = "wohnlage") %>% 
  mutate(bezirk = bezirk_levels[bezirk], property_type = property_type_levels[property_type]) %>% 
  pivot_longer(full_model_verbose_post_summary$parameter) %>% 
  rowwise() %>% 
  mutate(price_diff = exp(rnorm(1, log_price+value, sigma))-exp(rnorm(1, log_price, sigma))) %>%
  group_by(name) %>% 
  mutate(perc = str_c(round(100*mean(price_diff>0), 2), " %")) %>% 
  sample_n(20) %>% 
  ungroup() %>% 
  select(name, price_diff, perc)
```

```{r interactive-contrasts, echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, results="asis"}
cat(
  "<table>", 
  paste0("<caption>",
         "(#tab:full-model-parameter-summary)",
         "Summary of parameter estimations of the full model. If total effect equals <em>false</em> the parameter can only be interpreted as direct causal effect.",
         "</caption>"),
  "</table>", 
  sep ="\n"
  )

# set up a group of SharedData objects
shared_demo <- SharedData$new(
  full_model_verbose_post_summary, 
  key = ~parameter, group = "shared_obj"
  )
shared_trt <- SharedData$new(
  full_model_verbose_post_long %>% rename(parameter = name), 
  key = ~parameter, group = "shared_obj")
shared_trt2 <- SharedData$new(
  full_model_verbose_post_long_pred %>% rename(parameter = name), 
  key = ~parameter, group = "shared_obj")

# send the group to the filtering selection box
# filter_select(
#   id = "id-selector", label = "ID", 
#   sharedData = shared_demo, group = ~parameter
# )

datatable(
  shared_demo,
  selection = 'single'
  ) %>% 
  formatSignif(
    columns = 2:5,
    digits = 2
  )
# datatable(shared_trt)
```

```{r full-model-parameter-contrasts-interactive, echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, fig.cap="Contrasts of parameter estimations. The percentage indicates the probability to find an Airbnb with the chosen characteristic that is more expensive than an Airbnb without the characteristic.", fig.align='center', fig.dim = c(8, 3)}
gg_param <- shared_trt %>% 
  ggplot(aes(x = price_diff, group = parameter)) +
  geom_density(fill = "skyblue") +
  geom_text(aes(x = 20, 0.2, label = perc, group = parameter), hjust=0.5, vjust=0.5) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  labs(x="difference of mean price in €", y=NULL) +
  theme(
    legend.position = "bottom"
  )

ggplotly(gg_param)
```

```{r full-model-pred-contrasts-interactive, echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, fig.cap="Contrasts of posterior predicted prices. The percentage indicates the probability to find an Airbnb with the chosen characteristic that is more expensive than an Airbnb without the characteristic.", fig.align='center', fig.dim = c(8, 3)}
gg_pred <- shared_trt2 %>% 
  ggplot(aes(x = price_diff, group = parameter)) +
  geom_density(fill = "skyblue") +
  geom_text(aes(x = 250, 0.005, label = perc, group = parameter), hjust=0.5, vjust=0.5) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  labs(x="difference of mean price in €", y=NULL) +
  theme(
    legend.position = "bottom"
  )

ggplotly(gg_pred)
```

# Review and Title Sentiment Analysis

In this section, we analyze the sentiments of reviews and titles using existing sentiment analysis tools. Most tools in this field are designed to work with only one language and provide inaccurate analyses for texts in other languages. Therefore, our first step was to use a language detection tool to identify the languages of all texts. Upon determining the languages, we found that our reviews mostly consist of English and German reviews.

![Top 10 languages by review count](images/languages.png)

Due to the computational effort required to analyze reviews in all languages with our method (estimated 30 hours of computation time), we decided to analyze only the English and German texts. **das übersetzen hätte lange gebraucht, oder? Sonst erklärt sich kaum eine große Einsparung an sentiment analysis, da englisch und deutsch, ja bestimmt 50 % der reviews ausmachen**

For sentiment analysis, we used the [VADER Sentiment Analysis tool](https://github.com/cjhutto/vaderSentiment) for English texts and the [German Sentiment tool](https://github.com/oliverguhr/german-sentiment) for German texts. We also considered translating all texts into English after detecting the language using translation libraries that access APIs like Google Translate, as well as translation models. However, this approach also posed computational challenges (estimated > 10 hours). Consequently, we chose to focus solely on the English and German texts.

In the following sections, we will first evaluate the sentiment analysis of the titles and then of the reviews. Sentiments can be positive, negative or neutral. Both analysis tools also provide a percentage score for the sentiments. For the analysis, we assumed that the sentiment analysis tools did not produce fundamentally incorrect results. Additionally, both tools operate on entire texts and include the context of a text into the sentiment.

Here are three examples demonstrating the German sentiment analysis tool along with their translations:

- **die Wohnung stinkt** (the apartment stinks) -> negative
- **die Wohnung stinkt nicht** (the apartment does not stink) -> neutral
- **die Wohnung duftet** (the apartment smells) -> neutral

## Sentiment Analysis of Titles

To better understand the titles, we first performed a word analysis and filtered out the top entities from the titles.

![Wordcloud of Titles](images/wordcloud_titles.png)

From this, we can see that the most commonly used entities are the names of neighborhoods, which also have the most Airbnbs. Additionally, positive adjectives like "cozy" or "stylish" are often used in the titles of Airbnbs.

Based on the words used and the general expectation that hosts want to leave a positive impression on potential customers, our initial expectation was that most titles would have a positive or neutral sentiment. The following images will show the real distribution of sentiments.

```{r sentimentsTitles, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Sentiment count of titles", fig.align='center'}
ggplot(df_listings, aes(x = sentiment_for_name)) +
  geom_bar(fill = "skyblue", color = "black") +
  labs(title = "Sentiment count of titles", x = "Sentiment", y = "Count") +
  theme_minimal()
```

Here we can see that there are also some negative sentiments in the titles. This raises the question of what impact the sentiment of a title has on the price of an Airbnb. Does the sentiment of a title matter or could there be potential advantages to having a negative sentiment?

**Beispiele für negativ eingestufte titel?**

### Impact of title sentiments on price

Since we have some outliers in the price data, we will examine the price either within its 95% confidence interval or the log price. The 95% confidence interval is a range within which we expect the true price to lie 95% of the time, giving us a more reliable estimate by reducing the impact of extreme values. The following figures show the price of Airbnbs across different sentiment categories. **ich weiß nicht, ob ich das so sagen würde. Es ist ja hier noch gar keine Vorhersage, sondern konkrete daten oder? dann würde ich nicht confidence interval sagen. Und auf der logscala passen doch auch alle preise in die grafik oder?**

```{r violinPlotLogTitles, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Prices (log) of title sentiments", fig.align='center'}
ggplot(df_listings_cleaned, aes(x = sentiment_for_name, y = log_price, fill = sentiment_for_name)) +
  geom_violin(trim = TRUE) +
  geom_boxplot(width = 0.1, fill = "white") +
  labs(title = "Distribution of prices by sentiment", x = "Sentiment", y = "Log(Price)", fill="Sentiment") +
  theme_minimal()
```

When comparing sentiments with the log price, we can see that the prices of Airbnbs with negative sentiments are almost identical to those with neutral sentiments. Most reviews for both categories fall within a price between **4.3** and **4.9**. For positive sentiments, we observe a slightly different pattern. The number of high priced Airbnbs decreases earlier than in the negative and neutral categories, although the decline is less steep. This indicates that there are more Airbnbs with positive titles at higher prices. **anhand der boxplots würde ich ja auch sagen, dass bei den höherpreisigen wohnungen mehr liegen für good sentiment**

```{r violinPlotCITitles, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Prices (95% CI) of title sentiments", fig.align='center'}
mean_price <- mean(df_listings_cleaned$price)
# mean_price
sd_price <- sd(df_listings_cleaned$price)
# sd_price
z99 <- qnorm(0.975)
ci_low <- mean_price - z99 * sd_price / sqrt(nrow(df_listings_cleaned))
ci_high <- mean_price + z99 * sd_price / sqrt(nrow(df_listings_cleaned))

df_filtered <- df_listings_cleaned %>%
  filter(price >= ci_low & price <= ci_high)

ggplot(df_filtered, aes(x = sentiment_for_name, y = price, fill = sentiment_for_name)) +
  geom_violin(trim = FALSE) +
  geom_boxplot(width = 0.1, fill = "white") +
  labs(title = "Distribution of prices by sentiment", x = "Sentiment", y = "Price", fill="Sentiment") +
  theme_minimal()
```

If we take a look at the actual prices within the 95% confidence interval. Here, we can see a difference between negative and neutral sentiments. Prices for Airbnbs with negative sentiments are more evenly distributed than those with positive or neutral sentiments. Additionally, Airbnbs with neutral sentiments almost all have prices around 125€. For positive sentiments, we can see that there are more Airbnbs with higher prices compared to those with neutral or negative sentiments. **hier könnte es sinn machen, statt violinplots mit density approx mal auf histogramm artige darstellungen zu schauen**

In conclusion, there are small differences in price between the title sentiments. For Airbnb hosts it might be advantageous to use a positive sentiment in their titles to slightly increase the price. However, this would only be a minor factor. More important factors are likely to revolve around the preview images of an Airbnb.

## Sentiment analysis of reviews

As with the titles, we first took a general look at the reviews. We observed that there are very few negative reviews, with the majority being either positive or neutral.

```{r sentimentsOfreviews, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Sentiment count of reviews", fig.align='center'}
ggplot(df_review_sentiments, aes(x = sentiment)) +
  geom_bar(fill = "skyblue", color = "black") +
  labs(title = "Sentiment count of reviews", x = "Sentiment", y = "Count") +
  theme_minimal()

```

These results are surprising to us, as we expected a wider range of sentiments in the reviews, with a more balanced distribution of positive and negative sentiments. Our initial assumption was that reviews would tend to be strongly positive or negative, with fewer neutral ones, since users typically share personal experiences and opinions.  
We hypothesize that many reviews cover both positive and negative aspects, leading to their classification as neutral.

### Impact of review sentiments on price

As with the titles, we analyzed the log price and the 95% confidence interval for review sentiments.
[INSERT LOG PRICE IMAGE]

**zwischen title und review sentiments unterschieden in fig captions und text? irgendwie kalr machen, auf wie vielen datenpunkten die violinen jeweils beruhen, da dies doch recht untershciedlich ist?**

```{r violinPlotsReviewPrices, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Prices of review sentiments", fig.align='center'}
mean_price <- mean(df_listings_cleaned$price)
# mean_price
sd_price <- sd(df_listings_cleaned$price)
# sd_price
z99 <- qnorm(0.975)
ci_low <- mean_price - z99 * sd_price / sqrt(nrow(df_listings_cleaned))
ci_high <- mean_price + z99 * sd_price / sqrt(nrow(df_listings_cleaned))

log_price <- ggplot(df_review_sentiments, aes(x = sentiment, y = log_price, fill = sentiment)) +
  geom_violin(trim = TRUE) +
  geom_boxplot(width = 0.1, fill = "white") +
  labs(title = "Distribution of prices by sentiment", x = "Sentiment", y = "Price") +
  theme_minimal()

df_filtered <- df_review_sentiments %>%
  filter(price >= ci_low & price <= ci_high)

ci_price <- ggplot(df_filtered, aes(x = sentiment, y = price, fill = sentiment)) +
  geom_violin(trim = FALSE) +
  geom_boxplot(width = 0.1, fill = "white") +
  labs(title = "Distribution of prices by sentiment", x = "Sentiment", y = "Price") +
  theme_minimal()

grid.arrange(log_price, ci_price, ncol=2)
```

In the log price distribution, we observe a similar pattern to that seen with the titles. However, the price for Airbnbs with negative sentiments tends to be in a higher range compared to those with neutral or positive sentiments. **kann selections effekt sein. schlecht restaurant überleben, wo es viele turois gibt trotzdem. also können auch schlechte airbnbs teuer in prenzlauerberg liegen und es kommen trotzdem gäste - zwar nur ein mal, aber es werdn schon neue kommen xD gute restaurants überleben hingegen auch in der wallachei**  
The confidence interval price image provides a more precise view. Similar to the titles, the prices for Airbnbs with positive and negative review sentiments are almost identical. However, we can clearly see that negative sentiments are associated with a significant proportion of higher priced listings. This might be due to the fact that some higher priced Airbnbs do not necessarily offer better services compared to more affordable options that provide similar amenities. Customers may expect higher quality from more expensive listings and feel disappointed if those expectations are not met.

### Verteilung der Sentiments auf die Bezirke TODO
This section aims to explore how sentiments are distributed across different neighborhoods. This analysis may provide insights into whether certain neighborhoods have particularly appealing apartments or Airbnbs that reviewers find especially attractive. We will examine both the sentiments and the ratings given by reviewers.

#### Sentiments TODO

#### Rating vs Sentiments TODO

#### Sentiment compared to number of reviews TODO

#### Correlation between number of reviews and sentiment TODO

### Verteilung der Sentiments über Jahre und Monate TODO
Nimmt die Jahreszeit einen Einfluss auf das Sentiment der Reviews?

### How language affects sentiments
In this section, we aim to investigate whether English and German users behave differently in their reviews and Airbnb selection. Specifically, we want to determine if German or English users differ in their ratings and if there are preferred neighborhoods among either group. We don't have individual user ratings in our data, only the average rating for each Airbnb. Therefore, we use the sentiment of the reviews to analyze and understand the rating trends.

#### Distribution of languages across neighborhoods
We examined the distribution of English and German reviews across different neighborhoods to determine if German and English tourists show different preferences in their neighborhood choices. The following legend shows the mapping from percentages to colors.

```{r mappingColors, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Mapping percentage to color", fig.align='center'}
df_english_reviews <- df_review_sentiments %>%
  filter(language == "en")

df_german_reviews <- df_review_sentiments %>%
  filter(language == "de")

df_review_percentages <- df_review_sentiments %>%
  group_by(neighbourhood_group_cleansed) %>%
  summarize(
    total_reviews = n(),
    english_reviews = sum(language == "en"),
    german_reviews = sum(language == "de")
  ) %>%
  mutate(
    percent_english = english_reviews / nrow(df_english_reviews),
    percent_german = german_reviews / nrow(df_german_reviews)
  )

score_to_color <- function(score, min_score, max_score) {
  color_palette <- colorRampPalette(c("slateblue3", "lightblue", "limegreen"))(100)
  color_palette[as.numeric(cut(score, breaks = seq(min_score, max_score, length.out = 101), include.lowest = TRUE))]
}

bezirke_name_id <- tribble(
  ~BEZ_NAME, ~BEZ_ID,
  "Mitte", "01",
  "Friedrichshain-Kreuzberg", "02",
  "Pankow", "03",
  "Charlottenburg-Wilmersdorf", "04",
  "Spandau", "05",
  "Steglitz-Zehlendorf", "06",
  "Tempelhof-Schöneberg", "07",
  "Neukölln", "08",
  "Treptow-Köpenick", "09",
  "Marzahn-Hellersdorf", "10",
  "Lichtenberg", "11",
  "Reinickendorf", "12",
)

lor <- sf::st_read(dsn = "data/lor/Planung") %>% 
  st_make_valid(tol = 0.00001) %>% st_transform(4326) %>% 
  mutate(
    BEZ_ID = str_sub(PLR_ID, 1, 2),
    PGR_ID = str_sub(PLR_ID, 1, 4),
    BZR_ID = str_sub(PLR_ID, 1, 6)
  ) %>% 
  left_join(bezirke_name_id, by = c("BEZ_ID" = "BEZ_ID"))

lor <- left_join(lor, df_review_percentages, by = c("BEZ_NAME" = "neighbourhood_group_cleansed"))

min_percent <- min(df_review_percentages$percent_english, df_review_percentages$percent_german)
max_percent <- max(df_review_percentages$percent_english, df_review_percentages$percent_german)

lor_combined <- lor %>%
  group_by(BEZ_ID, BEZ_NAME) %>%
  summarize(
    geometry = st_union(geometry),
    percent_german = unique(percent_german),
    percent_english = unique(percent_english),
    .groups = 'drop'
  ) %>%
  mutate(
    color_german = score_to_color(percent_german, min_percent, max_percent),
    color_english = score_to_color(percent_english, min_percent, max_percent),
    label_combined = paste(BEZ_ID, BEZ_NAME, sep = ": ")
  )

data <- tibble(value = c(min_percent, max_percent))

legend_dummy <- ggplot(data, aes(x = value, y = 1, fill = value)) +
  geom_tile(height = 0, width = 0) +
  scale_fill_gradientn(colors = colorRampPalette(c("slateblue3", "lightblue", "limegreen"))(100), 
                       name = "Percentage") +
  labs(title = "", x = "Percentage", y = "") +
  theme(legend.position = "bottom") +
  theme_void()

legend <- cowplot::get_legend(legend_dummy)
grid.newpage()
grid.draw(legend)
```

The following map illustrates the percentage of reviews in each language relative to the total number of reviews for each neighborhood.

```{r distributionOfLanguagesOverneighborhoods, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Sentiment count of reviews", fig.align='center'}
plot_ger <- ggplot() +
  geom_sf(data = lor_combined, aes(geometry = geometry, fill = label_combined)) +
  geom_sf_text(data = lor_combined, aes(geometry = geometry, label = BEZ_ID), size = 3, color = "black") +
  scale_fill_manual(values = lor_combined$color_german, name = "Bezirke (ID: Name)") +
  theme_void() +
  labs(title = "Percentage of German Reviews") +
  theme(legend.position = "right", plot.title = element_text(hjust = 0.5))

plot_eng <- ggplot() +
  geom_sf(data = lor_combined, aes(geometry = geometry, fill = label_combined)) +
  geom_sf_text(data = lor_combined, aes(geometry = geometry, label = BEZ_ID), size = 3, color = "black") +
  scale_fill_manual(values = lor_combined$color_english, name = "Bezirke (ID: Name)") +
  theme_void() +
  labs(title = "Percentage of English Reviews") +
  theme(legend.position = "right", plot.title = element_text(hjust = 0.5))

grid.arrange(plot_ger, plot_eng, ncol=2)
```

This reveals that neighborhoods surrounding Berlin-Mitte are favored by both English and German visitors, with Kreuzberg and Pankow also ranking high in popularity. Notably, German visitors are more often in neighborhoods adjacent to Berlin-Mitte than the English visitors, such as Charlottenburg-Wilmersdorf and Tempelhof-Schöneberg. Airbnbs in outer districts like Marzahn-Hellersdorf and Spandau are less frequently visited by both English and German visitors. Overall, English reviewers show a strong preference for staying in or near Berlin-Mitte, while German reviewers exhibit a broader range of preferences, including more frequent stays in outer districts.

#### Verteilung der Sprachen auf die Monate TODO
Another interesting aspect to consider is whether German reviewers might choose different times to visit Berlin compared to English reviewers. We can determine this by analyzing the time of the reviews. For the following analysis our assumption is that visitors are likely to leave a review shortly after their stay rather than several months later.

[INSERT IMAGE]
[TODO: ANALYSIS]

#### Comparing between the English and German review sentiments
This chapter addresses whether English and German reviewers differ in the sentiment of their reviews. We analyzed the distribution of sentiment percentages for reviews in each language.

```{r comparisonEnglishVsGermanSentiments, echo=FALSE, message=FALSE, warning=FALSE, cache=!full_refit, fig.cap="Comparison between English and German sentiments", fig.align='center'}
df_percentage <- df_review_sentiments %>%
  group_by(language, sentiment) %>%
  summarise(count = n(), .groups = 'drop') %>%
  group_by(language) %>%
  mutate(total = sum(count),
         percentage = count / total * 100) %>%
  select(language, sentiment, percentage)

ggplot(df_percentage, aes(x = language, y = percentage, fill = sentiment)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Percentage of Sentiments by Language",
       x = "Language",
       y = "Percentage") +
  theme_minimal()
```

We observed that German reviews are predominantly positive, while English reviews are mostly neutral. Additionally, the sentiment distribution among German reviewers aligns more closely with our general expectations compared to the overall review sentiment overview. Germans tend to rate an Airbnb as either positive or negative, with very few neutral reviews. In contrast, English reviews are generally neutral, with very few negative reviews and occasional positive ones. It's also worth noting that the German and English reviews were analyzed using different sentiment analysis tools, which may have introduced biases towards positive or neutral sentiments. 

# References

<div id="refs"></div>

# Appendix

## Sources for inspiration

* [Scientific article on Berlin rents](https://link.springer.com/article/10.1007/s11943-024-00340-6): will we find similar effects for  rents?
* [Berlin Rents kaggle report](https://www.kaggle.com/code/gurjeet123/berlin-rent-insights): Are animals a price factor for Airbnb?
* [Airbnb repot on tableau](https://public.tableau.com/app/profile/ritik.mishra/viz/DataAnalysisofRentalPricesinBerlin/AirBnBBerlin?publish=yes): I think we can do better
* [Airbnb Berlin automated report for our base data set](https://insideairbnb.com/berlin/)

### Interactive graphs

* [Plotly](https://plotly-r.com/)

### Inteactive maps

* [tmap, ggplot2, mapview, mapdeck, leaflet](https://bookdown.org/nicohahn/making_maps_with_r5/docs/mapdeck.html)
* [Time slider with plotly](https://www.analytics-tuts.com/map-with-time-slider-using-plotly-in-r/)
* [SF with plotly](https://www.r-bloggers.com/2018/04/visualizing-geo-spatial-data-with-sf-and-plotly/)